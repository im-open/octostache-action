name: Build and Review PR
run-name: 'Build and Review PR #${{ github.event.pull_request.number }}'

on:
  # https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token
  #
  # This workflow uses the pull_request trigger which prevents write permissions on the
  # GH_TOKEN and secrets access from public forks.  This should remain as a pull_request
  # trigger to minimize the access public forks have in the repository.  The reduced
  # permissions are adequate but do mean that re-compiles and readme changes will have to be
  # made manually by the PR author.  These auto-updates could be done by this workflow
  # for branches but in order to re-trigger a PR build (which is needed for status checks),
  # we would make the commits with a different user and their PAT.  To minimize exposure
  # and complication we will request those changes be manually made by the PR author.
  pull_request:
    types: [opened, synchronize, reopened]
  # paths:
  #   Do not include specific paths here.  We always want this build to run and produce a
  #   status check which are branch protection rules can use.  If this is skipped because of
  #   path filtering, a status check will not be created and we won't be able to merge the PR
  #   without disabling that requirement.  If we have a status check that is always produced,
  #   we can also use that to require all branches be up to date before they are merged.

env:
  WORKFLOW_LEVEL_ENV: 'workflow-level-env' # Used in the tests

jobs:
  build-and-review-pr:
    # This reusable workflow will check to see if an action's source code has changed based on
    # whether the PR includes files that match the files-with-code arg or are in one of the
    # dirs-with-code directories.  If there are source code changes, this reusable workflow
    # will then run the action's build (if one was provided) and update the README.md with the
    # the latest version of the action.  If those two steps result in any changes that need to
    # be committed, the workflow will fail because the PR needs some updates.  Instructions for
    # updating the PR will be available in the build log, the workflow summary and as a PR
    # comment if the PR came from a branch (not a fork).
    # This workflow assumes:
    #  - The main README.md is at the root of the repo
    #  - The README contains a contribution guidelines and usage examples section
    uses: im-open/.github/.github/workflows/reusable-build-and-review-pr.yml@v1
    with:
      action-name: ${{ github.repository }}
      default-branch: main
      readme-name: 'README.md'

      # The id of the contribution guidelines section of the README.md
      readme-contribution-id: '#contributing'

      # The id of the usage examples section of the README.md
      readme-examples-id: '#usage-examples'

      # The files that contain source code for the action.  Only files that affect the action's execution
      # should be included like action.yml or package.json.  Do not include files like README.md or .gitignore.
      # Files do not need to be explicitly provided here if they fall under one of the dirs in dirs-with-code.
      # ** This value must match the same files-with-code argument specified in increment-version-on-merge.yml.
      files-with-code: 'action.yml,package-lock.json,package.json'

      # The directories that contain source code for the action.  Only dirs with files that affect the action's
      # execution should be included like src or dist.  Do not include dirs like .github or node_modules.
      # ** This value must match the same dirs-with-code argument specified in increment-version-on-merge.yml.
      dirs-with-code: 'src,.build-linux,.build-win'

      # This action does contain a build step but it always results in changes to the dlls, whether or not there
      # were actually code changes, so skip the build here.  When PRs are created, we need to make sure the
      # dlls have actually been updated.
      build-command: ''

  unit-tests:
    strategy:
      fail-fast: false
      matrix:
        # There are diferent executables for windows/linux so try it on both
        os: [ubuntu-latest, windows-latest]

    runs-on: ${{ matrix.os }}
    env:
      JOB_LEVEL_ENV: 'job-level-env' # Used in the tests

      # These env vars are reused and set for each test scenario
      FILE_WITH_SUBSTITUTIONS: ''
      ORIGINAL_FILE: ''
      EXPECTED_OUTPUT_FILE: ''

    steps:
      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                                    SETUP                                                    '
        run: echo ""

      - name: Setup - Checkout the action
        uses: actions/checkout@v4

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                 TEST 1 - EMPTY FILES-WITH-SUBSTITUTIONS ARG                                 '
        run: echo ""

      - name: 1a - When octostache-action is called with an empty files-with-substitutions
        id: missing-arg
        if: always()
        continue-on-error: true # This is needed because we expect the step to fail but we need it to "pass" in order for the test job to succeed.
        uses: ./
        with:
          files-with-substitutions: '  '

      - name: 1b - Then the action outcome should be failure
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "failure" --actual "${{ steps.missing-arg.outcome }}"

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                 TEST 2 - FILE WITH NO OCTOSTACHE TEMPLATES                                  '
        run: echo ""

      - name: Setup - Set variables for Test 2
        if: always()
        run: |
          destinationDirectory="./test-results/no-templates"
          fileName="no-octostache-templates.html"
          expectedOutputFile="./test/expected-output/no-templates.html"

          # Create a directory and copy the file to the destination
          # Make a copy so octostache can modify the file without changing the original
          destinationFile="$destinationDirectory/$fileName"
          originalFile="./test/input-files/$fileName"
          mkdir -p $destinationDirectory
          cp $originalFile $destinationFile

          echo "FILE_WITH_SUBSTITUTIONS=$destinationFile" >> "$GITHUB_ENV"
          echo "ORIGINAL_FILE=$originalFile" >> "$GITHUB_ENV"
          echo "EXPECTED_OUTPUT_FILE=$expectedOutputFile" >> "$GITHUB_ENV"

      - name: 2a - When octostache-action is called with a file that has no octostache templates to replace
        id: no-templates
        if: always()
        uses: ./
        with:
          files-with-substitutions: ${{ env.FILE_WITH_SUBSTITUTIONS }}

      - name: 2b - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.no-templates.outcome }}"

      - name: 2c - And '${{ env.FILE_WITH_SUBSTITUTIONS }}' should match the expected file, which is the same as the original file
        if: always()
        run: |
          expectedFileName="${{ env.EXPECTED_OUTPUT_FILE }}"
          actualFileName="${{ env.FILE_WITH_SUBSTITUTIONS }}"
          ./test/assert-file-contents-match.sh --expectedFileName $expectedFileName --actualFileName $actualFileName

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                             TEST 3 - FILE WITH NO MATCHING OCTOSTACHE TEMPLATES                             '
        run: echo ""

      - name: Setup - Set variables for Test 3
        if: always()
        run: |
          destinationDirectory="./test-results/no-matches"
          fileName="no-matching-templates.html"
          expectedOutputFile="./test/expected-output/no-matching.html"

          # Create a directory and copy the file to the destination
          # Make a copy so octostache can modify the file without changing the original
          destinationFile="$destinationDirectory/$fileName"
          originalFile="./test/input-files/$fileName"
          mkdir -p $destinationDirectory
          cp $originalFile $destinationFile

          echo "FILE_WITH_SUBSTITUTIONS=$destinationFile" >> "$GITHUB_ENV"
          echo "ORIGINAL_FILE=$originalFile" >> "$GITHUB_ENV"
          echo "EXPECTED_OUTPUT_FILE=$expectedOutputFile" >> "$GITHUB_ENV"

      - name: 3a - When octostache-action is called with a file that has octostache templates that do not match any inputs
        id: no-matching-templates
        if: always()
        uses: ./
        with:
          files-with-substitutions: ${{ env.FILE_WITH_SUBSTITUTIONS }}
          variables-file: ./test/input-files/substitution-variables.yml #(LaunchDarklyKey,GoogleAnalyticsKey,AppInsightsKey)
        env:
          Environment: Stage
          Version: 1.3.62

      - name: 3b - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.no-matching-templates.outcome }}"

      - name: 3c - And '${{ env.FILE_WITH_SUBSTITUTIONS }}' should match the expected file, which is the same as the original file
        if: always()
        run: |
          expectedFileName="${{ env.EXPECTED_OUTPUT_FILE }}"
          actualFileName="${{ env.FILE_WITH_SUBSTITUTIONS }}"
          ./test/assert-file-contents-match.sh --expectedFileName $expectedFileName --actualFileName $actualFileName

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                              TEST 4 - FILE WITH MATCHING OCTOSTACHE TEMPLATES                               '
        run: echo ""

      - name: Setup - Set variables for Test 4
        if: always()
        run: |
          destinationDirectory="./test-results/matching-templates"
          fileName="matching-octostache-templates.html"
          expectedOutputFile="./test/expected-output/matching-templates.html"

          # Create a directory and copy the file to the destination
          # Make a copy so octostache can modify the file without changing the original
          destinationFile="$destinationDirectory/$fileName"
          originalFile="./test/input-files/$fileName"
          mkdir -p $destinationDirectory
          cp $originalFile $destinationFile

          echo "FILE_WITH_SUBSTITUTIONS=$destinationFile" >> "$GITHUB_ENV"
          echo "ORIGINAL_FILE=$originalFile" >> "$GITHUB_ENV"
          echo "EXPECTED_OUTPUT_FILE=$expectedOutputFile" >> "$GITHUB_ENV"

      - name: 4a - When octostache-action is called with a file that has octostache templates that do not match any inputs
        id: matching-templates
        if: always()
        uses: ./
        with:
          files-with-substitutions: ${{ env.FILE_WITH_SUBSTITUTIONS }}
          variables-file: ./test/input-files/substitution-variables.yml #(LaunchDarklyKey,GoogleAnalyticsKey,AppInsightsKey)
        env:
          ENVIRONMENT: Stage
          VERSION: 1.3.62
          # GITHUB_SERVER_URL (Default GitHub variable - https://github.com)
          # WORKFLOW_LEVEL_ENV (workflow-level-env)
          # JOB_LEVEL_ENV (job-level-env)

      - name: 4b - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.matching-templates.outcome }}"

      - name: 4c - And '${{ env.FILE_WITH_SUBSTITUTIONS }}' should match the expected file, which has all the octostache templates replaced
        if: always()
        run: |
          expectedFileName="${{ env.EXPECTED_OUTPUT_FILE }}"
          actualFileName="${{ env.FILE_WITH_SUBSTITUTIONS }}"
          ./test/assert-file-contents-match.sh --expectedFileName $expectedFileName --actualFileName $actualFileName

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                 TEST 5 - OVERRIDE INPUT FILE WITH ENV VARS                                  '
        run: echo ""

      - name: Setup - Set variables for Test 5
        if: always()
        run: |
          destinationDirectory="./test-results/override-variables"
          fileName="override-variables.js"
          expectedOutputFile="./test/expected-output/override-variables.js"

          # Create a directory and copy the file to the destination
          # Make a copy so octostache can modify the file without changing the original
          destinationFile="$destinationDirectory/$fileName"
          originalFile="./test/input-files/$fileName"
          mkdir -p $destinationDirectory
          cp $originalFile $destinationFile

          echo "FILE_WITH_SUBSTITUTIONS=$destinationFile" >> "$GITHUB_ENV"
          echo "ORIGINAL_FILE=$originalFile" >> "$GITHUB_ENV"
          echo "EXPECTED_OUTPUT_FILE=$expectedOutputFile" >> "$GITHUB_ENV"

      - name: 5a - When octostache-action is called with env vars that override the input variables
        id: override-variables
        if: always()
        uses: ./
        with:
          files-with-substitutions: ${{ env.FILE_WITH_SUBSTITUTIONS }}
          variables-file: ./test/input-files/substitution-variables.yml #(LaunchDarklyKey,GoogleAnalyticsKey,AppInsightsKey)
        env:
          LaunchDarklyKey: override_ld_key
          GoogleAnalyticsKey: override_ga_key
          AppInsightsKey: override_ai_key

      - name: 5b - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.override-variables.outcome }}"

      - name: 5c - And '${{ env.FILE_WITH_SUBSTITUTIONS }}' should match the expected file, which replaced octostache templates with env var values
        if: always()
        run: |
          expectedFileName="${{ env.EXPECTED_OUTPUT_FILE }}"
          actualFileName="${{ env.FILE_WITH_SUBSTITUTIONS }}"
          ./test/assert-file-contents-match.sh --expectedFileName $expectedFileName --actualFileName $actualFileName

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                TEST 6 - MULTIPLE FILES-WITH-SUBSTITUTIONS ARG                               '
        run: echo ""

      - name: Setup - Set variables for Test 6
        if: always()
        run: |
          destinationDirectory="./test-results/multiple-files"

          fileName1="matching-octostache-templates.html"
          fileName2="override-variables.js"

          expectedOutputFile1="./test/expected-output/matching-templates.html"
          expectedOutputFile2="./test/expected-output/matching-templates.js"

          # Create a directory and copy the file to the destination
          # Make a copy so octostache can modify the file without changing the original
          destinationFile1="$destinationDirectory/$fileName1"
          destinationFile2="$destinationDirectory/$fileName2"

          originalFile1="./test/input-files/$fileName1"
          originalFile2="./test/input-files/$fileName2"

          mkdir -p $destinationDirectory
          cp $originalFile1 $destinationFile1
          cp $originalFile2 $destinationFile2

          echo "FILE_WITH_SUBSTITUTIONS_1=$destinationFile1" >> "$GITHUB_ENV"
          echo "FILE_WITH_SUBSTITUTIONS_2=$destinationFile2" >> "$GITHUB_ENV"

          echo "ORIGINAL_FILE_1=$originalFile1" >> "$GITHUB_ENV"
          echo "ORIGINAL_FILE_2=$originalFile2" >> "$GITHUB_ENV"

          echo "EXPECTED_OUTPUT_FILE_1=$expectedOutputFile1" >> "$GITHUB_ENV"
          echo "EXPECTED_OUTPUT_FILE_2=$expectedOutputFile2" >> "$GITHUB_ENV"

      - name: 6a - When octostache-action is called with env vars that override the input variables
        id: override-variables
        if: always()
        uses: ./
        with:
          files-with-substitutions: ${{ env.FILE_WITH_SUBSTITUTIONS_1 }},${{ env.FILE_WITH_SUBSTITUTIONS_2 }}
          variables-file: ./test/input-files/substitution-variables.yml #(LaunchDarklyKey,GoogleAnalyticsKey,AppInsightsKey)
        env:
          ENVIRONMENT: Stage
          VERSION: 1.3.62
          # GITHUB_SERVER_URL (Default GitHub variable - https://github.com)
          # WORKFLOW_LEVEL_ENV (workflow-level-env)
          # JOB_LEVEL_ENV (job-level-env)

      - name: 6b - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.override-variables.outcome }}"

      - name: 6c - And the touched files should match the expected files, which replaced octostache templates with env var & input values
        if: always()
        run: |
          expectedFileName="${{ env.EXPECTED_OUTPUT_FILE_1 }}"
          actualFileName="${{ env.FILE_WITH_SUBSTITUTIONS_1 }}"
          ./test/assert-file-contents-match.sh --expectedFileName $expectedFileName --actualFileName $actualFileName

          expectedFileName="${{ env.EXPECTED_OUTPUT_FILE_2 }}"
          actualFileName="${{ env.FILE_WITH_SUBSTITUTIONS_2 }}"
          ./test/assert-file-contents-match.sh --expectedFileName $expectedFileName --actualFileName $actualFileName
